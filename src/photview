#!/usr/bin/env python3
import sys
import os
import numpy as np
from astropy.io import fits  # FITS support

#import pyqtgraph as pg
#add a 'lazy import' for pyqtgraph

from PyQt6 import QtWidgets, QtCore, QtGui
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QFileDialog, QMessageBox, QInputDialog,
    QTableView, QVBoxLayout, QHBoxLayout, QWidget, QSlider, QListWidget, QListWidgetItem, QLabel,
    QTabBar, QStackedWidget
)

class NumpyTableModel(QtCore.QAbstractTableModel):
    def __init__(self, data, headers, parent=None):
        super().__init__(parent)
        self._data = data
        self._headers = headers

    def rowCount(self, parent=QtCore.QModelIndex()):
        return self._data.shape[0]

    def columnCount(self, parent=QtCore.QModelIndex()):
        return self._data.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DisplayRole:
            col_header = self._headers[index.column()].lower()
            raw_value = self._data[index.row(), index.column()]
            try:
                val = float(raw_value)
            except Exception:
                return str(raw_value)

            # Format "time": truncate to 6 decimal places at most.
            if col_header == "time":
                truncated = np.trunc(val * 1e6) / 1e6
                s = f"{truncated:.6f}"
                s = s.rstrip('0').rstrip('.') if '.' in s else s
                return s

            # Format "error": truncate to 2 significant digits.
            elif col_header == "error":
                if np.isnan(val):
                    return "nan"
                if val == 0:
                    return "0"
                exponent = np.floor(np.log10(abs(val)))
                scale = 10 ** (exponent - 2)
                truncated_val = np.floor(val / scale) * scale
                if abs(truncated_val) < 1e-2:
                    s = f"{truncated_val:.2e}"
                else:
                    s = format(truncated_val, ".2g")
                return s

            # Format "magnitude": if error isn’t NaN, use ceil(-log10(error)+1) decimals; else 4 decimals.
            elif col_header == "magnitude":
                headers_lower = [h.lower() for h in self._headers]
                if "error" in headers_lower:
                    error_idx = headers_lower.index("error")
                    try:
                        error_val = float(self._data[index.row(), error_idx])
                    except Exception:
                        error_val = np.nan
                    if np.isnan(error_val) or error_val == 0:
                        dp = 4
                    else:
                        dp = int(np.ceil(-np.log10(error_val) + 1))
                else:
                    dp = 4
                truncated = np.trunc(val * (10 ** dp)) / (10 ** dp)
                s = f"{truncated:.{dp}f}"
                s = s.rstrip('0').rstrip('.') if '.' in s else s
                return s

            else:
                return str(raw_value)
        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                if section < len(self._headers):
                    return self._headers[section]
            else:
                return str(section)
        return None

class LazyTableWidget(QWidget):
    """
    A widget that defers loading of file data until the tab is selected.
    When load_data() is called with force=True the widget re-reads the file.
    """
    def __init__(self, file_path, load_func, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.load_func = load_func  # Function to load the file (e.g. MainWindow.load_file)
        self.loaded = False
        self.layout = QVBoxLayout(self)
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)

    def load_data(self, force=False):
        if self.loaded and not force:
            return
        try:
            data, headers = self.load_func(self.file_path)
        except Exception as e:
            while self.layout.count():
                child = self.layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            error_label = QLabel(f"Error loading file:\n{e}")
            self.layout.addWidget(error_label)
            self.loaded = True
            return

        while self.layout.count():
            child = self.layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        base_filename = os.path.basename(self.file_path)
        filename_without_extension, _ = os.path.splitext(base_filename)
        filename_label = QLabel(filename_without_extension)
        filename_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(filename_label)

        table_view = QTableView()
        model = NumpyTableModel(data, headers)
        table_view.setModel(model)
        header = table_view.horizontalHeader()
        header.setStretchLastSection(False)
        for col in range(model.columnCount()):
            header.setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.layout.addWidget(table_view)
        self.loaded = True

    def clear_data(self):
        while self.layout.count():
            child = self.layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)
        self.loaded = False

class SearchLineEdit(QtWidgets.QLineEdit):
    def keyPressEvent(self, event: QtGui.QKeyEvent):
        # When Tab, Return, or Enter is pressed, emit the returnPressed signal.
        if event.key() in (Qt.Key.Key_Tab, Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.returnPressed.emit()
            event.accept()
            return
        super().keyPressEvent(event)

    def focusNextPrevChild(self, next: bool) -> bool:
        # Override to prevent Tab from moving focus away
        return False

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._suppress_load = False
        self.setWindowTitle("Photometry viewer")
        self.last_tab_index = None
        self.pending_files = []

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        self.main_layout = QVBoxLayout(central_widget)

        # --- Search Bar and Dynamic Search List ---
        search_layout = QHBoxLayout()
        self.search_bar = SearchLineEdit()  # Use the subclassed version
        self.search_bar.setPlaceholderText("Search ID")
        # Connect returnPressed to the search button’s click action
        self.search_bar.returnPressed.connect(lambda: self.search_button.click())
        self.search_bar.textChanged.connect(self.update_search_results)
        self.search_button = QtWidgets.QPushButton("Search")
        self.search_button.clicked.connect(lambda: self.update_search_results(self.search_bar.text()))
        search_layout.addWidget(self.search_bar)
        search_layout.addWidget(self.search_button)
        self.main_layout.addLayout(search_layout)

        self.search_results_list = QListWidget()
        self.search_results_list.hide()
        self.search_results_list.itemClicked.connect(self.on_search_item_clicked)
        self.main_layout.addWidget(self.search_results_list)

        # --- Tab Manager Layout ---
        self.tab_bar = QTabBar()
        self.tab_bar.currentChanged.connect(self.on_tab_changed)
        self.tab_bar.tabBarClicked.connect(self.on_tab_bar_clicked)
        self.main_layout.addWidget(self.tab_bar)

        self.tab_slider = QSlider(Qt.Orientation.Horizontal)
        self.tab_slider.setMinimum(0)
        self.tab_slider.valueChanged.connect(self.slider_tab_changed)
        self.main_layout.addWidget(self.tab_slider)

        # --- Reload and Close Tab Buttons ---
        button_layout = QHBoxLayout()
        self.reload_button = QtWidgets.QPushButton("Reload Current File")
        self.reload_button.clicked.connect(self.reload_current_tab)
        button_layout.addWidget(self.reload_button)
        self.close_tab_button = QtWidgets.QPushButton("Close Tab")
        self.close_tab_button.clicked.connect(self.close_current_tab)
        button_layout.addWidget(self.close_tab_button)
        self.main_layout.addLayout(button_layout)

        self.stack = QStackedWidget()
        self.main_layout.addWidget(self.stack)

        # --- Menu ---
        self.create_menu()

    def create_menu(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        open_menu = QtWidgets.QMenu("Open", self)

        direct_action = QtGui.QAction("Direct", self)
        direct_action.triggered.connect(self.open_file_direct)
        open_menu.addAction(direct_action)

        browse_action = QtGui.QAction("Browse", self)
        browse_action.triggered.connect(self.open_file)
        open_menu.addAction(browse_action)

        file_menu.addMenu(open_menu)

    def add_file_tab(self, file_path):
        file_path = file_path.strip().strip('\'"')
        if not os.path.isabs(file_path):
            file_path = os.path.abspath(file_path)

        if os.path.isdir(file_path):
            print(f"Skipping directory: {file_path}")
            return

        if not file_path.lower().endswith(('.dat', '.tsv', '.fit', '.fits')):
            print(f"Skipping file (invalid extension): {file_path}")
            return

        if not os.path.exists(file_path):
            QMessageBox.critical(self, "Error", f"File '{file_path}' not found.")
            return

        for i in range(self.stack.count()):
            widget = self.stack.widget(i)
            if hasattr(widget, "file_path") and widget.file_path == file_path:
                self.tab_bar.setCurrentIndex(i)
                self.stack.setCurrentIndex(i)
                return

        if file_path in self.pending_files:
            self.pending_files.remove(file_path)

        lazy_widget = LazyTableWidget(file_path, self.load_file)
        tab_label = os.path.basename(file_path)
        index = self.stack.addWidget(lazy_widget)
        self.tab_bar.addTab(tab_label)
        self.tab_bar.setCurrentIndex(index)
        self.stack.setCurrentIndex(index)
        self.update_slider_range()
        self.last_tab_index = index

    def open_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "Photometry files (*.tsv *.dat *.fit *.fits)"
        )
        if file_path:
            self.add_file_tab(file_path)

    def open_file_direct(self):
        text, ok = QInputDialog.getText(
            self, "Direct Open", "Enter file path(s) separated by spaces:"
        )
        if ok and text:
            paths = [p.strip() for p in text.split(" ") if p.strip()]
            for path in paths:
                self._process_path(path)

    def load_file(self, file_path):
        lower_path = file_path.lower()
        if lower_path.endswith(".dat"):
            delimiter = None
            try:
                data = np.loadtxt(file_path, delimiter=delimiter, dtype=float)
            except Exception as e:
                raise ValueError("File parsing error: " + str(e))
            if data.ndim == 1:
                data = data[np.newaxis, :]
            num_cols = data.shape[1]
            if num_cols < 2 or num_cols > 3:
                raise ValueError(f"File must have 2 or 3 columns, found {num_cols}.")
            headers = ["time", "magnitude"] if num_cols == 2 else ["time", "magnitude", "error"]
            return data, headers

        elif lower_path.endswith(".tsv"):
            delimiter = "\t"
            try:
                data = np.loadtxt(file_path, delimiter=delimiter, dtype=float)
            except Exception as e:
                raise ValueError("File parsing error: " + str(e))
            if data.ndim == 1:
                data = data[np.newaxis, :]
            num_cols = data.shape[1]
            if num_cols < 2 or num_cols > 3:
                raise ValueError(f"File must have 2 or 3 columns, found {num_cols}.")
            headers = ["time", "magnitude"] if num_cols == 2 else ["time", "magnitude", "error"]
            return data, headers

        elif lower_path.endswith(('.fit', '.fits')):
            try:
                with fits.open(file_path) as hdulist:
                    table_hdu = None
                    for hdu in hdulist:
                        if hdu.data is not None:
                            table_hdu = hdu
                            break
                    if table_hdu is None:
                        raise ValueError("No data found in FITS file.")
                    data_table = table_hdu.data
                    cols = table_hdu.columns.names
                    if "TIME" not in cols:
                        raise ValueError("TIME column not found in FITS file.")
                    if "PDCSAP_FLUX" not in cols:
                        raise ValueError("PDCSAP_FLUX column not found in FITS file.")
                    time = data_table["TIME"]
                    flux = data_table["PDCSAP_FLUX"]
                    valid = ~np.isnan(flux)
                    time = time[valid]
                    flux = flux[valid]
                    if "tess" in file_path.lower():
                        C = 20.67
                    else:
                        C = 0
                    magnitude = C - (2.5 * np.log10(flux))
                    if "PDCSAP_FLUX_ERR" in cols:
                        flux_err = data_table["PDCSAP_FLUX_ERR"][valid]
                        error = 1.08573625 * (flux_err / flux)
                        data = np.column_stack((time, magnitude, error))
                        headers = ["time", "magnitude", "error"]
                    else:
                        data = np.column_stack((time, magnitude))
                        headers = ["time", "magnitude"]
                    return data, headers
            except Exception as e:
                raise ValueError("FITS file parsing error: " + str(e))
        else:
            raise ValueError("Unsupported file extension.")

    def on_tab_changed(self, index):
        self.stack.setCurrentIndex(index)
        widget = self.stack.widget(index)
        if widget and hasattr(widget, 'load_data'):
            if not self._suppress_load:
                widget.load_data(force=False)
        self.tab_slider.blockSignals(True)
        self.tab_slider.setValue(index)
        self.tab_slider.blockSignals(False)
        self._suppress_load = False
        self.last_tab_index = index

    def on_tab_bar_clicked(self, index):
        if index == self.tab_bar.currentIndex():
            widget = self.stack.widget(index)
            if widget and hasattr(widget, 'load_data'):
                widget.load_data(force=True)

    def slider_tab_changed(self, value):
        if 0 <= value < self.stack.count():
            self._suppress_load = True
            self.tab_bar.setCurrentIndex(value)
            self.stack.setCurrentIndex(value)

    def reload_current_tab(self):
        index = self.tab_bar.currentIndex()
        widget = self.stack.widget(index)
        if widget and hasattr(widget, 'load_data'):
            widget.load_data(force=True)

    def close_current_tab(self):
        index = self.tab_bar.currentIndex()
        if index < 0:
            return
        widget = self.stack.widget(index)
        self.stack.removeWidget(widget)
        widget.deleteLater()
        self.tab_bar.removeTab(index)
        self.update_slider_range()
        if self.stack.count() > 0:
            new_index = max(0, index - 1)
            self.tab_bar.setCurrentIndex(new_index)
            self.stack.setCurrentIndex(new_index)
            self.last_tab_index = new_index
        else:
            self.last_tab_index = None

    def update_slider_range(self):
        count = self.stack.count()
        self.tab_slider.setMaximum(max(count - 1, 0))
        self.tab_slider.setEnabled(count > 1)

    def update_search_results(self, text):
        text = text.strip()
        self.search_results_list.clear()
        if not text:
            self.search_results_list.hide()
            return

        search_lower = text.lower()
        items = []

        for i in range(self.tab_bar.count()):
            tab_label = self.tab_bar.tabText(i)
            if search_lower in tab_label.lower():
                item = QListWidgetItem(tab_label)
                item.setData(Qt.ItemDataRole.UserRole, ("tab", i))
                items.append(item)

        sender = self.sender()
        if not (sender == self.search_bar and len(self.pending_files) > 8192):
            for file_path in self.pending_files:
                file_name = os.path.basename(file_path)
                if search_lower in file_name.lower():
                    item = QListWidgetItem(file_name)
                    item.setData(Qt.ItemDataRole.UserRole, ("pending", file_path))
                    items.append(item)

        items.sort(key=lambda item: item.text().lower())

        for item in items:
            self.search_results_list.addItem(item)

        if items:
            self.search_results_list.show()
        else:
            self.search_results_list.hide()

    def on_search_item_clicked(self, item):
        data = item.data(Qt.ItemDataRole.UserRole)
        if data[0] == "tab":
            index = data[1]
            self.tab_bar.setCurrentIndex(index)
            self.stack.setCurrentIndex(index)
        elif data[0] == "pending":
            file_path = data[1]
            self.add_file_tab(file_path)
        self.search_results_list.hide()

    def _process_path(self, path):
        path = os.path.abspath(path.strip().strip('\'"'))
        if os.path.isdir(path):
            for entry in os.listdir(path):
                full_path = os.path.join(path, entry)
                if os.path.isfile(full_path) and full_path.lower().endswith(('.dat', '.tsv', '.fit', '.fits')):
                    self.pending_files.append(full_path)
        elif os.path.isfile(path) and path.lower().endswith(('.dat', '.tsv', '.fit', '.fits')):
            self.pending_files.append(path)
        else:
            print(f"Warning: {path} is not a valid photometry file or directory.")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()

    for arg in sys.argv[1:]:
        if arg.strip():
            window._process_path(arg)

    if len(window.pending_files) <= 10:
        for file_path in window.pending_files.copy():
            window.add_file_tab(file_path)
    else:
        window.update_search_results(window.search_bar.text())

    window.resize(800, 600)
    window.show()
    sys.exit(app.exec())
