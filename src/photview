#!/usr/bin/env python3
import sys
import os
import struct
import numpy as np
from astropy.io import fits  # FITS support

from PyQt6 import QtWidgets, QtCore, QtGui
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QFileDialog, QMessageBox, QInputDialog,
    QTableView, QVBoxLayout, QHBoxLayout, QWidget, QSlider, QListWidget, QListWidgetItem, QLabel,
    QTabBar, QStackedWidget
)

# --- Phot64 Quantization Constants ---
TIME_QUANT = 1e-5      # for the 32-bit time field
Y_QUANT = 1.25e-4      # for the 20-bit y field
DY_QUANT = 2.5e-4      # for the 12-bit dy field

# -------------------------------
# Functions for loading & converting .phot64 files
# -------------------------------
def load_phot64_file(filepath):
    """
    Loads a .phot64 file fully into memory.
    Returns a list of photometry objects (dictionaries) where each object has:
       - "id": the object's ID (a string)
       - "allocated": padded size (an int)
       - "filled": actual number of measurements (an int)
       - "time": the time of the first measurement (a float)
       - "data": a numpy array of uint64 values containing the packed measurements
    """
    with open(filepath, "rb") as f:
        # Read the number of objects (uint64) and convert to a Python int.
        count = int(np.frombuffer(f.read(8), dtype='<u8')[0])

        # Read offsets (count+1 uint64 values)
        offsets = np.frombuffer(f.read(8 * (count + 1)), dtype='<u8')

        # Read the IDs block (each ID is exactly 64 bytes, padded with zeros)
        ids_array = np.frombuffer(f.read(count * 64), dtype='S64')
        ids = [s.decode('utf-8').rstrip('\x00') for s in ids_array]

        # Read the sizes block (allocated, filled, and time for each object; stored as doubles)
        sizes = np.frombuffer(f.read(count * 24), dtype='<f8').reshape((count, 3))
        allocated = sizes[:, 0]
        filled = sizes[:, 1]
        first_times = sizes[:, 2]

        # Total number of uint64 values in the data block is given by the last offset.
        total_data = int(offsets[-1])
        data = np.frombuffer(f.read(total_data * 8), dtype='<u8')

        objects = []
        for i in range(count):
            start = int(offsets[i])
            end = int(offsets[i+1])
            # Copy the slice so that each object’s data is independent.
            raw_data = data[start:end].copy()
            obj = {
                "id": ids[i],
                "allocated": int(allocated[i]),
                "filled": int(filled[i]),
                "time": first_times[i],
                "data": raw_data  # still in packed uint64 format
            }
            objects.append(obj)
    return objects

def convert_phot64_data(phot64_obj):
    """
    Converts the packed uint64 data for a phot64 object into a float table.
    Only the first 'filled' measurements are converted.
    Returns (data, headers), where data is a 2D numpy array with columns:
         time, magnitude, error.
    The conversion uses the global quantization constants.
    """
    # Use only the first "filled" elements (the rest are zero padding).
    raw_data = phot64_obj["data"][:phot64_obj["filled"]]
    raw_data = np.asarray(raw_data, dtype=np.uint64)

    # Extract fields:
    time_int = raw_data >> 32
    y_packed = (raw_data >> 12) & 0xFFFFF  # 20 bits for magnitude (sign–magnitude)
    dy_int = raw_data & 0xFFF              # 12 bits for error

    # Convert y_packed to signed integer:
    sign_mask = 1 << 19
    y_int = np.where((y_packed & sign_mask) != 0, - (y_packed & 0x7FFFF), y_packed)

    # Reconstruct the actual values.
    time_vals = phot64_obj["time"] + time_int.astype(np.float64) * TIME_QUANT
    mag_vals = y_int.astype(np.float64) * Y_QUANT
    err_vals = dy_int.astype(np.float64) * DY_QUANT

    data = np.column_stack((time_vals, mag_vals, err_vals))
    return data, ["time", "magnitude", "error"]

# -------------------------------
# Lazy widget for phot64 object tabs
# -------------------------------
class LazyPhot64ObjectWidget(QWidget):
    """
    A widget for displaying a single phot64 object.
    The widget stores the file path and the phot64 object metadata.
    Data conversion from the raw uint64 measurements to floats is done
    only when load_data() is called (e.g. when the tab is selected).
    """
    def __init__(self, file_path, phot64_obj, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.phot64_obj = phot64_obj
        self.loaded = False
        self.layout = QVBoxLayout(self)
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)

    def load_data(self, force=False):
        if self.loaded and not force:
            return
        try:
            data, headers = convert_phot64_data(self.phot64_obj)
        except Exception as e:
            while self.layout.count():
                child = self.layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            error_label = QLabel(f"Error loading phot64 object data:\n{e}")
            self.layout.addWidget(error_label)
            self.loaded = True
            return

        while self.layout.count():
            child = self.layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        # Show only the object's ID here (instead of file/ID).
        id_label = QLabel(self.phot64_obj['id'])
        id_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(id_label)

        table_view = QTableView()
        model = NumpyTableModel(data, headers)
        table_view.setModel(model)
        header = table_view.horizontalHeader()
        header.setStretchLastSection(False)
        for col in range(model.columnCount()):
            header.setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.layout.addWidget(table_view)
        self.loaded = True

# -------------------------------
# Original Lazy widget for non–phot64 files (unchanged)
# -------------------------------
class LazyTableWidget(QWidget):
    """
    A widget that defers loading of file data until the tab is selected.
    When load_data() is called with force=True the widget re-reads the file.
    """
    def __init__(self, file_path, load_func, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.load_func = load_func  # Function to load the file (e.g. MainWindow.load_file)
        self.loaded = False
        self.layout = QVBoxLayout(self)
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)

    def load_data(self, force=False):
        if self.loaded and not force:
            return
        try:
            data, headers = self.load_func(self.file_path)
        except Exception as e:
            while self.layout.count():
                child = self.layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            error_label = QLabel(f"Error loading file:\n{e}")
            self.layout.addWidget(error_label)
            self.loaded = True
            return

        while self.layout.count():
            child = self.layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        base_filename = os.path.basename(self.file_path)
        filename_without_extension, _ = os.path.splitext(base_filename)
        filename_label = QLabel(filename_without_extension)
        filename_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(filename_label)

        table_view = QTableView()
        model = NumpyTableModel(data, headers)
        table_view.setModel(model)
        header = table_view.horizontalHeader()
        header.setStretchLastSection(False)
        for col in range(model.columnCount()):
            header.setSectionResizeMode(col, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.layout.addWidget(table_view)
        self.loaded = True

    def clear_data(self):
        while self.layout.count():
            child = self.layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)
        self.loaded = False

# -------------------------------
# Table model (unchanged)
# -------------------------------
class NumpyTableModel(QtCore.QAbstractTableModel):
    def __init__(self, data, headers, parent=None):
        super().__init__(parent)
        self._data = data
        self._headers = headers

    def rowCount(self, parent=QtCore.QModelIndex()):
        return self._data.shape[0]

    def columnCount(self, parent=QtCore.QModelIndex()):
        return self._data.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DisplayRole:
            col_header = self._headers[index.column()].lower()
            raw_value = self._data[index.row(), index.column()]
            try:
                val = float(raw_value)
            except Exception:
                return str(raw_value)

            # Format "time": truncate to 6 decimal places at most.
            if col_header == "time":
                truncated = np.trunc(val * 1e6) / 1e6
                s = f"{truncated:.6f}"
                s = s.rstrip('0').rstrip('.') if '.' in s else s
                return s

            # Format "error": truncate to 2 significant digits.
            elif col_header == "error":
                if np.isnan(val):
                    return "nan"
                if val == 0:
                    return "0"
                exponent = np.floor(np.log10(abs(val)))
                scale = 10 ** (exponent - 2)
                truncated_val = np.floor(val / scale) * scale
                if abs(truncated_val) < 1e-2:
                    s = f"{truncated_val:.2e}"
                else:
                    s = format(truncated_val, ".2g")
                return s

            # Format "magnitude": if error isn’t NaN, use ceil(-log10(error)+1) decimals; else 4 decimals.
            elif col_header == "magnitude":
                headers_lower = [h.lower() for h in self._headers]
                if "error" in headers_lower:
                    error_idx = headers_lower.index("error")
                    try:
                        error_val = float(self._data[index.row(), error_idx])
                    except Exception:
                        error_val = np.nan
                    if np.isnan(error_val) or error_val == 0:
                        dp = 4
                    else:
                        dp = int(np.ceil(-np.log10(error_val) + 1))
                else:
                    dp = 4
                truncated = np.trunc(val * (10 ** dp)) / (10 ** dp)
                s = f"{truncated:.{dp}f}"
                s = s.rstrip('0').rstrip('.') if '.' in s else s
                return s

            else:
                return str(raw_value)
        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                if section < len(self._headers):
                    return self._headers[section]
            else:
                return str(section)
        return None

# -------------------------------
# Customized Search LineEdit (unchanged)
# -------------------------------
class SearchLineEdit(QtWidgets.QLineEdit):
    def keyPressEvent(self, event: QtGui.QKeyEvent):
        # When Tab, Return, or Enter is pressed, emit the returnPressed signal.
        if event.key() in (Qt.Key.Key_Tab, Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.returnPressed.emit()
            event.accept()
            return
        super().keyPressEvent(event)

    def focusNextPrevChild(self, next: bool) -> bool:
        # Override to prevent Tab from moving focus away
        return False

# -------------------------------
# Main window with added .phot64 support
# -------------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._suppress_load = False
        self.setWindowTitle("Photometry viewer")
        self.last_tab_index = None
        self.pending_files = []  # for non–phot64 files
        self.phot64_objects = []  # list of tuples: (file_path, phot64_object)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        self.main_layout = QVBoxLayout(central_widget)

        # --- Search Bar and Dynamic Search List ---
        search_layout = QHBoxLayout()
        self.search_bar = SearchLineEdit()  # Use the subclassed version
        self.search_bar.setPlaceholderText("Search ID")
        # Connect returnPressed to the search button’s click action
        self.search_bar.returnPressed.connect(lambda: self.search_button.click())
        self.search_bar.textChanged.connect(self.update_search_results)
        self.search_button = QtWidgets.QPushButton("Search")
        self.search_button.clicked.connect(lambda: self.update_search_results(self.search_bar.text()))
        search_layout.addWidget(self.search_bar)
        search_layout.addWidget(self.search_button)
        self.main_layout.addLayout(search_layout)

        self.search_results_list = QListWidget()
        self.search_results_list.hide()
        self.search_results_list.itemClicked.connect(self.on_search_item_clicked)
        self.main_layout.addWidget(self.search_results_list)

        # --- Tab Manager Layout ---
        self.tab_bar = QTabBar()
        self.tab_bar.currentChanged.connect(self.on_tab_changed)
        self.tab_bar.tabBarClicked.connect(self.on_tab_bar_clicked)
        self.main_layout.addWidget(self.tab_bar)

        self.tab_slider = QSlider(Qt.Orientation.Horizontal)
        self.tab_slider.setMinimum(0)
        self.tab_slider.valueChanged.connect(self.slider_tab_changed)
        self.main_layout.addWidget(self.tab_slider)

        # --- Reload and Close Tab Buttons ---
        button_layout = QHBoxLayout()
        self.reload_button = QtWidgets.QPushButton("Reload Current File")
        self.reload_button.clicked.connect(self.reload_current_tab)
        button_layout.addWidget(self.reload_button)
        self.close_tab_button = QtWidgets.QPushButton("Close Tab")
        self.close_tab_button.clicked.connect(self.close_current_tab)
        button_layout.addWidget(self.close_tab_button)
        self.main_layout.addLayout(button_layout)

        self.stack = QStackedWidget()
        self.main_layout.addWidget(self.stack)

        # --- Menu ---
        self.create_menu()

    def create_menu(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        open_menu = QtWidgets.QMenu("Open", self)

        direct_action = QtGui.QAction("Direct", self)
        direct_action.triggered.connect(self.open_file_direct)
        open_menu.addAction(direct_action)

        browse_action = QtGui.QAction("Browse", self)
        browse_action.triggered.connect(self.open_file)
        open_menu.addAction(browse_action)

        file_menu.addMenu(open_menu)

    def add_file_tab(self, file_path):
        file_path = file_path.strip().strip('\'"')
        if not os.path.isabs(file_path):
            file_path = os.path.abspath(file_path)

        if os.path.isdir(file_path):
            print(f"Skipping directory: {file_path}")
            return

        # For phot64 files, use the separate handler.
        if file_path.lower().endswith(".phot64"):
            self.add_phot64_file(file_path)
            self.update_search_results(self.search_bar.text())
            return

        if not file_path.lower().endswith(('.dat', '.tsv', '.fit', '.fits')):
            print(f"Skipping file (invalid extension): {file_path}")
            return

        if not os.path.exists(file_path):
            QMessageBox.critical(self, "Error", f"File '{file_path}' not found.")
            return

        for i in range(self.stack.count()):
            widget = self.stack.widget(i)
            if hasattr(widget, "file_path") and widget.file_path == file_path:
                self.tab_bar.setCurrentIndex(i)
                self.stack.setCurrentIndex(i)
                return

        if file_path in self.pending_files:
            self.pending_files.remove(file_path)

        lazy_widget = LazyTableWidget(file_path, self.load_file)
        tab_label = os.path.basename(file_path)
        index = self.stack.addWidget(lazy_widget)
        self.tab_bar.addTab(tab_label)
        self.tab_bar.setCurrentIndex(index)
        self.stack.setCurrentIndex(index)
        self.update_slider_range()
        self.last_tab_index = index

    def add_phot64_file(self, file_path):
        """
        Loads a phot64 file and stores each contained object for later access.
        """
        try:
            phot_objects = load_phot64_file(file_path)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error loading phot64 file:\n{e}")
            return
        for obj in phot_objects:
            # Each item is a tuple: (file_path, phot64_object)
            self.phot64_objects.append((file_path, obj))
        print(f"Loaded {len(phot_objects)} objects from {file_path}.")

    def add_phot64_tab(self, file_path, phot64_obj):
        # Check if a tab for this phot64 object already exists.
        for i in range(self.stack.count()):
            widget = self.stack.widget(i)
            if hasattr(widget, "file_path") and hasattr(widget, "phot64_obj"):
                if widget.file_path == file_path and widget.phot64_obj["id"] == phot64_obj["id"]:
                    self.tab_bar.setCurrentIndex(i)
                    self.stack.setCurrentIndex(i)
                    return
        widget = LazyPhot64ObjectWidget(file_path, phot64_obj)
        tab_label = f"{os.path.basename(file_path)}/{phot64_obj['id']}"
        index = self.stack.addWidget(widget)
        self.tab_bar.addTab(tab_label)
        self.tab_bar.setCurrentIndex(index)
        self.stack.setCurrentIndex(index)
        self.update_slider_range()

    def open_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "Photometry files (*.tsv *.dat *.fit *.fits *.phot64)"
        )
        if file_path:
            if file_path.lower().endswith(".phot64"):
                self.add_phot64_file(file_path)
                self.update_search_results(self.search_bar.text())
            else:
                self.add_file_tab(file_path)

    def open_file_direct(self):
        text, ok = QInputDialog.getText(
            self, "Direct Open", "Enter file path(s) separated by spaces:"
        )
        if ok and text:
            paths = [p.strip() for p in text.split(" ") if p.strip()]
            for path in paths:
                self._process_path(path)

    def load_file(self, file_path):
        lower_path = file_path.lower()
        if lower_path.endswith(".dat"):
            delimiter = None
            try:
                data = np.loadtxt(file_path, delimiter=delimiter, dtype=float)
            except Exception as e:
                raise ValueError("File parsing error: " + str(e))
            if data.ndim == 1:
                data = data[np.newaxis, :]
            num_cols = data.shape[1]
            if num_cols < 2 or num_cols > 3:
                raise ValueError(f"File must have 2 or 3 columns, found {num_cols}.")
            headers = ["time", "magnitude"] if num_cols == 2 else ["time", "magnitude", "error"]
            return data, headers

        elif lower_path.endswith(".tsv"):
            delimiter = "\t"
            try:
                data = np.loadtxt(file_path, delimiter=delimiter, dtype=float)
            except Exception as e:
                raise ValueError("File parsing error: " + str(e))
            if data.ndim == 1:
                data = data[np.newaxis, :]
            num_cols = data.shape[1]
            if num_cols < 2 or num_cols > 3:
                raise ValueError(f"File must have 2 or 3 columns, found {num_cols}.")
            headers = ["time", "magnitude"] if num_cols == 2 else ["time", "magnitude", "error"]
            return data, headers

        elif lower_path.endswith(('.fit', '.fits')):
            try:
                with fits.open(file_path) as hdulist:
                    table_hdu = None
                    for hdu in hdulist:
                        if hdu.data is not None:
                            table_hdu = hdu
                            break
                    if table_hdu is None:
                        raise ValueError("No data found in FITS file.")
                    data_table = table_hdu.data
                    cols = table_hdu.columns.names
                    if "TIME" not in cols:
                        raise ValueError("TIME column not found in FITS file.")
                    if "PDCSAP_FLUX" not in cols:
                        raise ValueError("PDCSAP_FLUX column not found in FITS file.")
                    time = data_table["TIME"]
                    flux = data_table["PDCSAP_FLUX"]
                    valid = ~np.isnan(flux)
                    time = time[valid]
                    flux = flux[valid]
                    if "tess" in file_path.lower():
                        C = 20.67
                    else:
                        C = 0
                    magnitude = C - (2.5 * np.log10(flux))
                    if "PDCSAP_FLUX_ERR" in cols:
                        flux_err = data_table["PDCSAP_FLUX_ERR"][valid]
                        error = 1.08573625 * (flux_err / flux)
                        data = np.column_stack((time, magnitude, error))
                        headers = ["time", "magnitude", "error"]
                    else:
                        data = np.column_stack((time, magnitude))
                        headers = ["time", "magnitude"]
                    return data, headers
            except Exception as e:
                raise ValueError("FITS file parsing error: " + str(e))
        else:
            raise ValueError("Unsupported file extension.")

    def on_tab_changed(self, index):
        self.stack.setCurrentIndex(index)
        widget = self.stack.widget(index)
        if widget and hasattr(widget, 'load_data'):
            if not self._suppress_load:
                widget.load_data(force=False)
        self.tab_slider.blockSignals(True)
        self.tab_slider.setValue(index)
        self.tab_slider.blockSignals(False)
        self._suppress_load = False
        self.last_tab_index = index

    def on_tab_bar_clicked(self, index):
        if index == self.tab_bar.currentIndex():
            widget = self.stack.widget(index)
            if widget and hasattr(widget, 'load_data'):
                widget.load_data(force=True)

    def slider_tab_changed(self, value):
        if 0 <= value < self.stack.count():
            self._suppress_load = True
            self.tab_bar.setCurrentIndex(value)
            self.stack.setCurrentIndex(value)

    def reload_current_tab(self):
        index = self.tab_bar.currentIndex()
        widget = self.stack.widget(index)
        if widget and hasattr(widget, 'load_data'):
            widget.load_data(force=True)

    def close_current_tab(self):
        index = self.tab_bar.currentIndex()
        if index < 0:
            return
        widget = self.stack.widget(index)
        self.stack.removeWidget(widget)
        widget.deleteLater()
        self.tab_bar.removeTab(index)
        self.update_slider_range()
        if self.stack.count() > 0:
            new_index = max(0, index - 1)
            self.tab_bar.setCurrentIndex(new_index)
            self.stack.setCurrentIndex(new_index)
            self.last_tab_index = new_index
        else:
            self.last_tab_index = None

    def update_slider_range(self):
        count = self.stack.count()
        self.tab_slider.setMaximum(max(count - 1, 0))
        self.tab_slider.setEnabled(count > 1)

    def update_search_results(self, text):
        text = text.strip()
        self.search_results_list.clear()
        if not text:
            self.search_results_list.hide()
            return

        search_lower = text.lower()
        items = []

        # First, add items for already open tabs (non–phot64 files).
        for i in range(self.tab_bar.count()):
            tab_label = self.tab_bar.tabText(i)
            if search_lower in tab_label.lower():
                item = QListWidgetItem(tab_label)
                item.setData(Qt.ItemDataRole.UserRole, ("tab", i))
                items.append(item)

        # Next, add pending files (non–phot64).
        for file_path in self.pending_files:
            file_name = os.path.basename(file_path)
            if search_lower in file_name.lower():
                item = QListWidgetItem(file_name)
                item.setData(Qt.ItemDataRole.UserRole, ("pending", file_path))
                items.append(item)

        # Finally, add phot64 objects.
        for (fpath, obj) in self.phot64_objects:
            label = f"{os.path.basename(fpath)}/{obj['id']}"
            if search_lower in label.lower():
                item = QListWidgetItem(label)
                item.setData(Qt.ItemDataRole.UserRole, ("phot64", fpath, obj))
                items.append(item)

        # If there is any non-phot64 result, sort the items;
        # otherwise, leave phot64 items in file–order.
        if any(item.data(Qt.ItemDataRole.UserRole)[0] in ("tab", "pending") for item in items):
            items.sort(key=lambda item: item.text().lower())

        for item in items:
            self.search_results_list.addItem(item)

        if items:
            self.search_results_list.show()
        else:
            self.search_results_list.hide()

    def on_search_item_clicked(self, item):
        data = item.data(Qt.ItemDataRole.UserRole)
        if data[0] == "tab":
            index = data[1]
            self.tab_bar.setCurrentIndex(index)
            self.stack.setCurrentIndex(index)
        elif data[0] == "pending":
            file_path = data[1]
            self.add_file_tab(file_path)
        elif data[0] == "phot64":
            file_path = data[1]
            phot64_obj = data[2]
            self.add_phot64_tab(file_path, phot64_obj)
        self.search_results_list.hide()

    def _process_path(self, path):
        path = os.path.abspath(path.strip().strip('\'"'))
        if os.path.isdir(path):
            for entry in os.listdir(path):
                full_path = os.path.join(path, entry)
                if os.path.isfile(full_path) and full_path.lower().endswith(('.dat', '.tsv', '.fit', '.fits', '.phot64')):
                    # For phot64 files, process them separately.
                    if full_path.lower().endswith('.phot64'):
                        self.add_phot64_file(full_path)
                    else:
                        self.pending_files.append(full_path)
        elif os.path.isfile(path) and path.lower().endswith(('.dat', '.tsv', '.fit', '.fits', '.phot64')):
            if path.lower().endswith('.phot64'):
                self.add_phot64_file(path)
            else:
                self.pending_files.append(path)
        else:
            print(f"Warning: {path} is not a valid photometry file or directory.")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()

    # Process command-line arguments.
    for arg in sys.argv[1:]:
        if arg.strip():
            window._process_path(arg)

    # If only a few non–phot64 files are pending, open them as tabs.
    if len(window.pending_files) <= 10:
        for file_path in window.pending_files.copy():
            window.add_file_tab(file_path)
    else:
        window.update_search_results(window.search_bar.text())

    window.resize(800, 600)
    window.show()
    sys.exit(app.exec())
