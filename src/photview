#!/usr/bin/env python3
import sys, os, struct
import numpy as np
from astropy.io import fits  # FITS support
from PyQt6 import QtWidgets, QtCore, QtGui
from PyQt6.QtCore import Qt, QLocale, QPointF
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QFileDialog, QMessageBox, QInputDialog, QTableView, QVBoxLayout, QDialog, QDialogButtonBox, QGraphicsLineItem,
    QHBoxLayout, QWidget, QSlider, QListWidget, QListWidgetItem, QLabel, QTabBar, QStackedWidget, QFormLayout, QDoubleSpinBox
)
from PyQt6.QtCharts import QChart, QChartView, QScatterSeries, QLineSeries, QValueAxis

class InteractiveChartView(QChartView):
    def __init__(self, chart, clamp_callback, parent=None):
        super().__init__(chart, parent)
        self.clamp_mode = False
        self.first_click_value = None
        self.clamp_callback = clamp_callback  # Callback to apply clamping

class LazyWidgetBase(QWidget):
    def __init__(self, file_path, parent=None):
        super().__init__(parent)
        self.file_path = file_path
        self.loaded = False
        self.layout = QVBoxLayout(self)
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)
        self.data = None
        self.headers = None
        self.table_view = None
        self.chart_view = None
        self.is_plot_shown = False
        self.content_widget = None  # Tracks current main content widget
        self._saving_plot = False
        # For interactive clamping using sliders.
        self.clamp_sliders_active = False
        self.clamp_slider_widget = None
        self.slider_scale = 10000.0  # Scale factor to convert float to int for slider precision
        # For displaying horizontal clamp lines
        self.clamp_line_min_series = None
        self.clamp_line_max_series = None
        # To store axis ranges (computed without NaNs)
        self.x_min = None
        self.x_max = None
        self.y_min = None
        self.y_max = None
        # Will be set in show_plot:
        self.chart = None
        self.axisX = None
        self.axisY = None

    def clear_layout(self):
        while self.layout.count():
            child = self.layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

    def load_data(self, force=False):
        if self.loaded and not force:
            return
        try:
            data, headers = self._load_data_impl()
        except Exception as e:
            self.clear_layout()
            error_label = QLabel(f"{self._get_error_prefix()}\n{e}")
            self.layout.addWidget(error_label)
            self.loaded = True
            return

        self.clear_layout()
        title = self._get_data_title()
        title_label = QLabel(title)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(title_label)

        self.table_view = QTableView()
        model = NumpyTableModel(data, headers)
        self.table_view.setModel(model)
        header = self.table_view.horizontalHeader()
        header.setStretchLastSection(False)
        for col in range(model.columnCount()):
            header.setSectionResizeMode(
                col, QtWidgets.QHeaderView.ResizeMode.ResizeToContents
            )
        self.layout.addWidget(self.table_view)

        self.data = data
        self.headers = headers
        self.loaded = True
        self.content_widget = self.table_view

    def clear_data(self):
        self.clear_layout()
        self.placeholder = QLabel("Data not loaded yet. Select a tab to load.")
        self.layout.addWidget(self.placeholder)
        self.loaded = False

    def show_plot(self):
        if self.data is None or self.data.shape[0] == 0:
            return

        n = self.data.shape[0]
        chart = QChart()
        chart.setTitle(self._get_plot_title())
        series = QScatterSeries()
        marker_size = 50 / n**(0.25)
        series.setMarkerSize(marker_size)
        series.setPen(QtGui.QPen(QtGui.QColor(0, 0, 0, 0)))
        series.setBrush(QtGui.QBrush(QtGui.QColor("blue")))
        for t, y in self._get_plot_series_data():
            series.append(t, y)
        chart.addSeries(series)

        axisX = QValueAxis()
        axisY = QValueAxis()
        axisX.setTitleText("Time")
        axisY.setTitleText("Magnitude")
        chart.addAxis(axisX, Qt.AlignmentFlag.AlignBottom)
        chart.addAxis(axisY, Qt.AlignmentFlag.AlignLeft)
        series.attachAxis(axisX)
        series.attachAxis(axisY)
        self._configure_axes(axisX, axisY)

        # Save the chart and axes for later use (e.g. for clamping lines)
        self.chart = chart
        self.axisX = axisX
        self.axisY = axisY

        if self.content_widget is not None:
            self.layout.removeWidget(self.content_widget)
            self.content_widget.hide()

        self.chart_view = QChartView(chart)
        # Create a container widget with buttons above the chart.
        plot_container = QWidget()
        container_layout = QVBoxLayout(plot_container)
        self.plot_container_layout = container_layout  # Save the layout for later use
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()  # Push buttons to the right side

        # Create the Clamp button (which toggles clamp mode) and Save Plot button.
        clamp_button = QtWidgets.QPushButton("Clamp")
        save_button = QtWidgets.QPushButton("Save Plot")
        buttons_layout.addWidget(clamp_button)
        buttons_layout.addWidget(save_button)
        container_layout.addLayout(buttons_layout)
        container_layout.addWidget(self.chart_view)

        clamp_button.clicked.connect(self.toggle_clamp_mode)
        save_button.clicked.connect(self.save_plot)

        self.content_widget = plot_container
        self.layout.addWidget(self.content_widget)
        self.is_plot_shown = True

    def _configure_axes(self, axisX, axisY):
        # Use np.nanmin/np.nanmax to ignore NaNs when computing the range.
        data = getattr(self, "plot_data_col_major", self.data)
        if data is None or data.shape[0] == 0:
            return
        x = data[:, 0]
        y = data[:, 1]
        # Compute min/max ignoring NaNs
        xmin = float(np.nanmin(x))
        xmax = float(np.nanmax(x))
        ymin = float(np.nanmin(y))
        ymax = float(np.nanmax(y))
        margin_x = (xmax - xmin) * 0.025
        margin_y = (ymax - ymin) * 0.05
        axisX.setRange(xmin - margin_x, xmax + margin_x)
        axisY.setRange(ymax + margin_y, ymin - margin_y)  # note: magnitude axis is inverted
        # Save computed ranges for use with the horizontal clamp lines
        self.x_min = xmin - margin_x
        self.x_max = xmax + margin_x
        self.y_min = ymin - margin_y
        self.y_max = ymax + margin_y

    def create_clamp_sliders(self, default_min, default_max):
        """Creates a slider panel for setting min and max clamp values and adds horizontal lines to the chart."""
        self.clamp_slider_widget = QWidget()
        slider_layout = QHBoxLayout(self.clamp_slider_widget)

        min_int = int(default_min * self.slider_scale)
        max_int = int(default_max * self.slider_scale)

        min_label = QLabel(f"Min: {default_min:.4f}")
        self.min_slider = QtWidgets.QSlider(Qt.Orientation.Horizontal)
        self.min_slider.setRange(min_int, max_int)
        self.min_slider.setValue(min_int)
        self.min_slider.valueChanged.connect(lambda value: min_label.setText(f"Min: {value/self.slider_scale:.4f}"))
        # Also update the horizontal line position when the slider moves.
        self.min_slider.valueChanged.connect(lambda value: self.update_clamp_lines())

        max_label = QLabel(f"Max: {default_max:.4f}")
        self.max_slider = QtWidgets.QSlider(Qt.Orientation.Horizontal)
        self.max_slider.setRange(min_int, max_int)
        self.max_slider.setValue(max_int)
        self.max_slider.valueChanged.connect(lambda value: max_label.setText(f"Max: {value/self.slider_scale:.4f}"))
        self.max_slider.valueChanged.connect(lambda value: self.update_clamp_lines())

        slider_layout.addWidget(min_label)
        slider_layout.addWidget(self.min_slider)
        slider_layout.addWidget(max_label)
        slider_layout.addWidget(self.max_slider)

        # Add the slider widget to the plot container layout (below the chart)
        self.plot_container_layout.addWidget(self.clamp_slider_widget)
        # Add horizontal lines for clamp min and max
        self.add_clamp_lines(default_min, default_max)

    def add_clamp_lines(self, min_val, max_val):
        """Adds two horizontal lines to the chart at the given min and max values."""
        self.clamp_line_min_series = QLineSeries()
        self.clamp_line_min_series.setName("Min")
        pen = QtGui.QPen(QtGui.QColor("red"))
        pen.setWidth(2)
        self.clamp_line_min_series.setPen(pen)

        self.clamp_line_max_series = QLineSeries()
        self.clamp_line_max_series.setName("Max")
        pen2 = QtGui.QPen(QtGui.QColor("red"))
        pen2.setWidth(2)
        self.clamp_line_max_series.setPen(pen2)

        # Use the saved x-range to cover the full horizontal span
        x_min = self.x_min if self.x_min is not None else self.axisX.min()
        x_max = self.x_max if self.x_max is not None else self.axisX.max()
        self.clamp_line_min_series.append(x_min, min_val)
        self.clamp_line_min_series.append(x_max, min_val)
        self.clamp_line_max_series.append(x_min, max_val)
        self.clamp_line_max_series.append(x_max, max_val)

        self.chart.addSeries(self.clamp_line_min_series)
        self.chart.addSeries(self.clamp_line_max_series)
        self.clamp_line_min_series.attachAxis(self.axisX)
        self.clamp_line_min_series.attachAxis(self.axisY)
        self.clamp_line_max_series.attachAxis(self.axisX)
        self.clamp_line_max_series.attachAxis(self.axisY)

    def update_clamp_lines(self):
        """Updates the horizontal lines according to the current slider values."""
        if self.clamp_line_min_series is None or self.clamp_line_max_series is None:
            return
        clamp_min = self.min_slider.value() / self.slider_scale
        clamp_max = self.max_slider.value() / self.slider_scale
        x_min = self.x_min if self.x_min is not None else self.axisX.min()
        x_max = self.x_max if self.x_max is not None else self.axisX.max()
        self.clamp_line_min_series.clear()
        self.clamp_line_max_series.clear()
        self.clamp_line_min_series.append(x_min, clamp_min)
        self.clamp_line_min_series.append(x_max, clamp_min)
        self.clamp_line_max_series.append(x_min, clamp_max)
        self.clamp_line_max_series.append(x_max, clamp_max)

    def toggle_clamp_mode(self):
        """
        Toggles interactive clamp mode using sliders. On the first press, two sliders
        for minimum and maximum magnitudes are added below the plot along with horizontal lines.
        When pressed again, the current slider values are read, the sliders (and horizontal lines)
        are removed, and clamping is applied.
        """
        if not self.clamp_sliders_active:
            if self.data is None or self.data.shape[0] == 0:
                return
            magnitudes = self.data[:, 1]
            default_min = float(np.nanmin(magnitudes))
            default_max = float(np.nanmax(magnitudes))
            self.create_clamp_sliders(default_min, default_max)
            self.clamp_sliders_active = True
        else:
            # Read slider values (scaling back to float values)
            if self.clamp_slider_widget is None:
                return
            clamp_min = self.min_slider.value() / self.slider_scale
            clamp_max = self.max_slider.value() / self.slider_scale
            # Remove the slider widget.
            self.plot_container_layout.removeWidget(self.clamp_slider_widget)
            self.clamp_slider_widget.deleteLater()
            self.clamp_slider_widget = None
            self.clamp_sliders_active = False
            # Remove the horizontal clamp lines from the chart.
            if self.clamp_line_min_series:
                self.chart.removeSeries(self.clamp_line_min_series)
                self.clamp_line_min_series = None
            if self.clamp_line_max_series:
                self.chart.removeSeries(self.clamp_line_max_series)
                self.clamp_line_max_series = None
            self.apply_clamp(clamp_min, clamp_max)

    def apply_clamp(self, min_val, max_val):
        if self.data is None or self.data.shape[0] == 0:
            return
        if min_val > max_val:
            QtWidgets.QMessageBox.warning(
                self, "Invalid Range",
                "Minimum magnitude must be less than or equal to maximum magnitude."
            )
            return
        # Set entire row to NaN if the magnitude (column index 1) is out-of-range.
        for i in range(self.data.shape[0]):
            mag = self.data[i, 1]
            if mag < min_val or mag > max_val:
                self.data[i, :] = np.nan

        # Remove rows that were clamped (all values are NaN)
        self.data = self.data[~np.isnan(self.data).all(axis=1)]
        if self.table_view is not None:
            new_model = NumpyTableModel(self.data, self.headers)
            self.table_view.setModel(new_model)

        # Regenerate the plot with the clamped (and filtered) data.
        if self.is_plot_shown:
            self.show_plot()

    def hide_plot(self):
        if self.content_widget is not None and self.is_plot_shown:
            self.layout.removeWidget(self.content_widget)
            self.content_widget.hide()
            self.content_widget.deleteLater()
            self.content_widget = self.table_view
            self.layout.addWidget(self.content_widget)
            self.content_widget.show()
            self.is_plot_shown = False
            main_window = self.window()
            if isinstance(main_window, MainWindow):
                main_window.setup_normal_buttons()

    def save_plot(self):
        if self.chart_view is None:
            return
        self._saving_plot = True  # Prevent hideEvent from auto–closing the plot
        pixmap = self.chart_view.grab()
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Plot", "",
            "PNG Files (*.png);;JPEG Files (*.jpg *.jpeg);;All Files (*)"
        )
        if filename:
            pixmap.save(filename)
        self._saving_plot = False

    def hideEvent(self, event):
        if self.is_plot_shown and not self._saving_plot:
            self.hide_plot()
        super().hideEvent(event)

    def showEvent(self, event):
        if self.is_plot_shown and not self._saving_plot:
            self.hide_plot()
        super().showEvent(event)

    def _get_plot_series_data(self):
        for row in self.data:
            if np.isnan(row[0]) or np.isnan(row[1]):
                continue
            yield float(row[0]), float(row[1])

    # --- Hook methods for subclasses to implement ---
    def _load_data_impl(self):
        raise NotImplementedError

    def _get_data_title(self):
        raise NotImplementedError

    def _get_error_prefix(self):
        return "Error loading data:"

    def _get_plot_title(self):
        return "Plot"

# -------------------------------
# Main window with added .phot64 support and plotting functionality
# -------------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._suppress_load = False
        self.setWindowTitle("Photometry viewer")
        self.last_tab_index = None
        self.pending_files = []  # for non–phot64 files
        self.phot64_objects = []  # list of tuples: (file_path, phot64_object)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        self.main_layout = QVBoxLayout(central_widget)

        # --- Search Bar and Dynamic Search List ---
        search_layout = QHBoxLayout()
        self.search_bar = SearchLineEdit()  # Use the subclassed version
        self.search_bar.setPlaceholderText("Search ID")
        # Connect forceSearch (from Tab, Enter, or Space) to force a full search.
        self.search_bar.forceSearch.connect(lambda: self.update_search_results(self.search_bar.text(), True))
        # Also, textChanged will trigger an automatic search.
        self.search_bar.textChanged.connect(lambda text: self.update_search_results(text, False))
        self.search_button = QtWidgets.QPushButton("Search")
        # Clicking the search button forces a full search.
        self.search_button.clicked.connect(lambda: self.update_search_results(self.search_bar.text(), True))
        search_layout.addWidget(self.search_bar)
        search_layout.addWidget(self.search_button)
        self.main_layout.addLayout(search_layout)

        self.search_results_list = QListWidget()
        self.search_results_list.hide()
        self.search_results_list.itemClicked.connect(self.on_search_item_clicked)
        self.main_layout.addWidget(self.search_results_list)

        # --- Tab Manager Layout ---
        self.tab_bar = QTabBar()
        self.tab_bar.currentChanged.connect(self.on_tab_changed)
        self.tab_bar.tabBarClicked.connect(self.on_tab_bar_clicked)
        self.main_layout.addWidget(self.tab_bar)

        self.tab_slider = QSlider(Qt.Orientation.Horizontal)
        self.tab_slider.setMinimum(0)
        self.tab_slider.valueChanged.connect(self.slider_tab_changed)
        self.main_layout.addWidget(self.tab_slider)

        # --- Reload, Plot, and Close Tab Buttons ---
        self.button_layout = QHBoxLayout()
        self.setup_normal_buttons()  # [NEW] Setup initial buttons: Reload, Plot, Close Tab
        self.main_layout.addLayout(self.button_layout)

        self.stack = QStackedWidget()
        self.main_layout.addWidget(self.stack)

        # --- Menu ---
        self.create_menu()

    def setup_normal_buttons(self):  # [NEW] Buttons shown when no plot is active
        # Clear existing buttons
        while self.button_layout.count():
            item = self.button_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        self.plot_button = QtWidgets.QPushButton("Plot")
        self.plot_button.clicked.connect(self.plot_current_tab)
        self.button_layout.addWidget(self.plot_button)
        self.reload_button = QtWidgets.QPushButton("Reload Current File")
        self.reload_button.clicked.connect(self.reload_current_tab)
        self.button_layout.addWidget(self.reload_button)
        self.close_tab_button = QtWidgets.QPushButton("Close Tab")
        self.close_tab_button.clicked.connect(self.close_current_tab)
        self.button_layout.addWidget(self.close_tab_button)

    def setup_plot_buttons(self):  # [NEW] Buttons shown when plot is active
        while self.button_layout.count():
            item = self.button_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        self.hide_plot_button = QtWidgets.QPushButton("Hide plot")
        self.hide_plot_button.clicked.connect(self.hide_plot_current_tab)
        self.button_layout.addWidget(self.hide_plot_button)
        self.fold_button = QtWidgets.QPushButton("Fold data")
        self.fold_button.clicked.connect(self.fold_current_tab)
        self.button_layout.addWidget(self.fold_button)
        self.detrend_button = QtWidgets.QPushButton("Detrend/Prewhiten")
        self.detrend_button.clicked.connect(self.detrend_current_tab)
        self.button_layout.addWidget(self.detrend_button)

    def create_menu(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("File")
        open_menu = QtWidgets.QMenu("Open", self)

        direct_action = QtGui.QAction("Direct", self)
        direct_action.triggered.connect(self.open_file_direct)
        open_menu.addAction(direct_action)

        browse_action = QtGui.QAction("Browse", self)
        browse_action.triggered.connect(self.open_file)
        open_menu.addAction(browse_action)

        file_menu.addMenu(open_menu)

    def add_file_tab(self, file_path):
        file_path = file_path.strip().strip('\'"')
        if not os.path.isabs(file_path):
            file_path = os.path.abspath(file_path)

        if os.path.isdir(file_path):
            print(f"Skipping directory: {file_path}")
            return

        # For phot64 files, use the separate handler.
        if file_path.lower().endswith(".phot64"):
            self.add_phot64_file(file_path)
            self.update_search_results(self.search_bar.text(), False)
            return

        if not file_path.lower().endswith(('.dat', '.tsv', '.fit', '.fits')):
            print(f"Skipping file (invalid extension): {file_path}")
            return

        if not os.path.exists(file_path):
            QMessageBox.critical(self, "Error", f"File '{file_path}' not found.")
            return

        for i in range(self.stack.count()):
            widget = self.stack.widget(i)
            if hasattr(widget, "file_path") and widget.file_path == file_path:
                self.tab_bar.setCurrentIndex(i)
                self.stack.setCurrentIndex(i)
                return

        if file_path in self.pending_files:
            self.pending_files.remove(file_path)

        lazy_widget = LazyTableWidget(file_path, self.load_file)
        tab_label = os.path.basename(file_path)
        index = self.stack.addWidget(lazy_widget)
        self.tab_bar.addTab(tab_label)
        self.tab_bar.setCurrentIndex(index)
        self.stack.setCurrentIndex(index)
        self.update_slider_range()
        self.last_tab_index = index

    def add_phot64_file(self, file_path):
        """
        Loads a phot64 file and stores each contained object for later access.
        """
        try:
            phot_objects = load_phot64_file(file_path)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error loading phot64 file:\n{e}")
            return
        for obj in phot_objects:
            # Each item is a tuple: (file_path, phot64_object)
            self.phot64_objects.append((file_path, obj))
        print(f"Loaded {len(phot_objects)} objects from {file_path}.")

    def add_phot64_tab(self, file_path, phot64_obj):
        # Check if a tab for this phot64 object already exists.
        for i in range(self.stack.count()):
            widget = self.stack.widget(i)
            if hasattr(widget, "file_path") and hasattr(widget, "phot64_obj"):
                if widget.file_path == file_path and widget.phot64_obj["id"] == phot64_obj["id"]:
                    self.tab_bar.setCurrentIndex(i)
                    self.stack.setCurrentIndex(i)
                    return
        widget = LazyPhot64ObjectWidget(file_path, phot64_obj)
        tab_label = f"{os.path.basename(file_path)}/{phot64_obj['id']}"
        index = self.stack.addWidget(widget)
        self.tab_bar.addTab(tab_label)
        self.tab_bar.setCurrentIndex(index)
        self.stack.setCurrentIndex(index)
        self.update_slider_range()

    def open_file(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Open File", "", "Photometry files (*.tsv *.dat *.fit *.fits *.phot64)"
        )
        if file_path:
            if file_path.lower().endswith(".phot64"):
                self.add_phot64_file(file_path)
                self.update_search_results(self.search_bar.text(), False)
            else:
                self.add_file_tab(file_path)

    def open_file_direct(self):
        text, ok = QInputDialog.getText(
            self, "Direct Open", "Enter file path(s) separated by spaces:"
        )
        if ok and text:
            paths = [p.strip() for p in text.split(" ") if p.strip()]
            for path in paths:
                self._process_path(path)

    def load_file(self, file_path):
        lower_path = file_path.lower()
        if lower_path.endswith(".dat"):
            delimiter = None
            try:
                data = np.loadtxt(file_path, delimiter=delimiter, dtype=float)
            except Exception as e:
                raise ValueError("File parsing error: " + str(e))
            if data.ndim == 1:
                data = data[np.newaxis, :]
            num_cols = data.shape[1]
            if num_cols < 2 or num_cols > 3:
                raise ValueError(f"File must have 2 or 3 columns, found {num_cols}.")
            headers = ["time", "magnitude"] if num_cols == 2 else ["time", "magnitude", "error"]
            return data, headers

        elif lower_path.endswith(".tsv"):
            delimiter = "\t"
            try:
                data = np.loadtxt(file_path, delimiter=delimiter, dtype=float)
            except Exception as e:
                raise ValueError("File parsing error: " + str(e))
            if data.ndim == 1:
                data = data[np.newaxis, :]
            num_cols = data.shape[1]
            if num_cols < 2 or num_cols > 3:
                raise ValueError(f"File must have 2 or 3 columns, found {num_cols}.")
            headers = ["time", "magnitude"] if num_cols == 2 else ["time", "magnitude", "error"]
            return data, headers

        elif lower_path.endswith(('.fit', '.fits')):
            try:
                with fits.open(file_path) as hdulist:
                    table_hdu = None
                    for hdu in hdulist:
                        if hdu.data is not None:
                            table_hdu = hdu
                            break
                    if table_hdu is None:
                        raise ValueError("No data found in FITS file.")
                    data_table = table_hdu.data
                    cols = table_hdu.columns.names
                    if "TIME" not in cols:
                        raise ValueError("TIME column not found in FITS file.")
                    if "PDCSAP_FLUX" not in cols:
                        raise ValueError("PDCSAP_FLUX column not found in FITS file.")
                    time = data_table["TIME"]
                    flux = data_table["PDCSAP_FLUX"]
                    valid = ~np.isnan(flux)
                    time = time[valid]
                    flux = flux[valid]
                    if "tess" in file_path.lower():
                        C = 20.67
                    else:
                        C = 0
                    magnitude = C - (2.5 * np.log10(flux))
                    if "PDCSAP_FLUX_ERR" in cols:
                        flux_err = data_table["PDCSAP_FLUX_ERR"][valid]
                        error = 1.08573625 * (flux_err / flux)
                        data = np.column_stack((time, magnitude, error))
                        headers = ["time", "magnitude", "error"]
                    else:
                        data = np.column_stack((time, magnitude))
                        headers = ["time", "magnitude"]
                    return data, headers
            except Exception as e:
                raise ValueError("FITS file parsing error: " + str(e))
        else:
            raise ValueError("Unsupported file extension.")

    def on_tab_changed(self, index):
        self.stack.setCurrentIndex(index)
        widget = self.stack.widget(index)
        if widget and hasattr(widget, 'load_data'):
            if not self._suppress_load:
                widget.load_data(force=False)
        self.tab_slider.blockSignals(True)
        self.tab_slider.setValue(index)
        self.tab_slider.blockSignals(False)
        self._suppress_load = False
        self.last_tab_index = index

    def on_tab_bar_clicked(self, index):
        if index == self.tab_bar.currentIndex():
            widget = self.stack.widget(index)
            if widget and hasattr(widget, 'load_data'):
                widget.load_data(force=True)

    def slider_tab_changed(self, value):
        if 0 <= value < self.stack.count():
            self._suppress_load = True
            self.tab_bar.setCurrentIndex(value)
            self.stack.setCurrentIndex(value)

    def reload_current_tab(self):
        index = self.tab_bar.currentIndex()
        widget = self.stack.widget(index)
        if widget and hasattr(widget, 'load_data'):
            widget.load_data(force=True)

    def close_current_tab(self):
        index = self.tab_bar.currentIndex()
        if index < 0:
            return
        widget = self.stack.widget(index)

        # If this is a non–phot64 file tab (LazyTableWidget), add its file_path back to pending_files.
        if hasattr(widget, "file_path") and not hasattr(widget, "phot64_obj"):
            if widget.file_path not in self.pending_files:
                self.pending_files.append(widget.file_path)

        self.stack.removeWidget(widget)
        widget.deleteLater()
        self.tab_bar.removeTab(index)
        self.update_slider_range()
        if self.stack.count() > 0:
            new_index = max(0, index - 1)
            self.tab_bar.setCurrentIndex(new_index)
            self.stack.setCurrentIndex(new_index)
            self.last_tab_index = new_index
        else:
            self.last_tab_index = None

    def update_slider_range(self):
        count = self.stack.count()
        self.tab_slider.setMaximum(max(count - 1, 0))
        self.tab_slider.setEnabled(count > 1)

    def update_search_results(self, text, force_all=False):
        """
        When force_all is True (triggered by Tab/Enter or search button),
        search among ALL available objects (open tabs, pending files, phot64 objects).
        Otherwise, if the total unloaded count (pending+phot64) is 1000 or more,
        search only among already open tabs.
        """
        text = text.strip()
        self.search_results_list.clear()
        if not text:
            self.search_results_list.hide()
            return

        search_lower = text.lower()
        items = []

        # Count unloaded items (pending files and phot64 objects)
        total_unloaded = len(self.pending_files) + len(self.phot64_objects)

        if force_all or total_unloaded < 1000:
            # Also search among pending files
            for file_path in self.pending_files:
                file_name = os.path.basename(file_path)
                if search_lower in file_name.lower():
                    item = QListWidgetItem(file_name)
                    item.setData(Qt.ItemDataRole.UserRole, ("pending", file_path))
                    items.append(item)
            # And among phot64 objects
            for (fpath, obj) in self.phot64_objects:
                label = f"{os.path.basename(fpath)}/{obj['id']}"
                if search_lower in label.lower():
                    item = QListWidgetItem(label)
                    item.setData(Qt.ItemDataRole.UserRole, ("phot64", fpath, obj))
                    items.append(item)
        else:
            # Only search among already open tabs
            for i in range(self.tab_bar.count()):
                tab_label = self.tab_bar.tabText(i)
                if search_lower in tab_label.lower():
                    item = QListWidgetItem(tab_label)
                    item.setData(Qt.ItemDataRole.UserRole, ("tab", i))
                    items.append(item)

        if any(item.data(Qt.ItemDataRole.UserRole)[0] in ("tab", "pending") for item in items):
            items.sort(key=lambda item: item.text().lower())

        for item in items:
            self.search_results_list.addItem(item)

        if items:
            self.search_results_list.show()
        else:
            self.search_results_list.hide()

    def on_search_item_clicked(self, item):
        data = item.data(Qt.ItemDataRole.UserRole)
        if data[0] == "tab":
            index = data[1]
            self.tab_bar.setCurrentIndex(index)
            self.stack.setCurrentIndex(index)
        elif data[0] == "pending":
            file_path = data[1]
            self.add_file_tab(file_path)
        elif data[0] == "phot64":
            file_path = data[1]
            phot64_obj = data[2]
            self.add_phot64_tab(file_path, phot64_obj)
        self.search_results_list.hide()

    # [NEW] Method called when the Plot button is pressed.
    def plot_current_tab(self):
        widget = self.stack.currentWidget()
        if widget and hasattr(widget, 'show_plot') and not widget.is_plot_shown:
            widget.show_plot()
            self.setup_plot_buttons()

    # [NEW] Method called when Hide plot is pressed.
    def hide_plot_current_tab(self):
        widget = self.stack.currentWidget()
        if widget and hasattr(widget, 'hide_plot') and widget.is_plot_shown:
            widget.hide_plot()
            self.setup_normal_buttons()

    # [NEW] Placeholder for Detrend/Prewhiten functionality.
    def detrend_current_tab(self):
        QMessageBox.information(self, "Info", "Detrend/Prewhiten not implemented.")

    # [NEW] Placeholder for Fold data functionality.
    def fold_current_tab(self):
        QMessageBox.information(self, "Info", "Fold data not implemented.")

    def _process_path(self, path):
        path = os.path.abspath(path.strip().strip('\'"'))
        if os.path.isdir(path):
            for entry in os.listdir(path):
                full_path = os.path.join(path, entry)
                if os.path.isfile(full_path) and full_path.lower().endswith(('.dat', '.tsv', '.fit', '.fits', '.phot64')):
                    # For phot64 files, process them separately.
                    if full_path.lower().endswith('.phot64'):
                        self.add_phot64_file(full_path)
                    else:
                        self.pending_files.append(full_path)
        elif os.path.isfile(path) and path.lower().endswith(('.dat', '.tsv', '.fit', '.fits', '.phot64')):
            if path.lower().endswith('.phot64'):
                self.add_phot64_file(path)
            else:
                self.pending_files.append(path)
        else:
            print(f"Warning: {path} is not a valid photometry file or directory.")

# --- Phot64 Quantization Constants ---
TIME_QUANT = 1e-5      # for the 32-bit time field
Y_QUANT = 1.25e-4      # for the 20-bit y field
DY_QUANT = 2.5e-4      # for the 12-bit dy field

# -------------------------------
# Functions for loading & converting .phot64 files
# -------------------------------
def load_phot64_file(filepath):
    with open(filepath, "rb") as f:
        # Read the global header: two uint64_t values (count, max_filled)
        header = np.frombuffer(f.read(16), dtype='<u8')
        count = int(header[0])
        max_filled = int(header[1])  # This value is read but not used further.

        # Read the offsets array.
        offsets = np.frombuffer(f.read(8 * (count + 1)), dtype='<u8')

        # Read the IDs block.
        ids_array = np.frombuffer(f.read(count * 64), dtype='S64')
        ids = [s.decode('utf-8').rstrip('\x00') for s in ids_array]

        # Read the sizes block.
        # Note: allocated and filled are now stored as uint64_t, and t0 as a double.
        sizes_dtype = np.dtype([("allocated", "<u8"), ("filled", "<u8"), ("t0", "<f8")])
        sizes = np.frombuffer(f.read(count * 24), dtype=sizes_dtype)
        allocated = sizes["allocated"]
        filled = sizes["filled"]
        first_times = sizes["t0"]

        # Read the data block.
        total_data = int(offsets[-1])
        data = np.frombuffer(f.read(total_data * 8), dtype='<u8')

        objects = []
        for i in range(count):
            start = int(offsets[i])
            end = int(offsets[i+1])
            raw_data = data[start:end].copy()
            obj = {
                "id": ids[i],
                "allocated": int(allocated[i]),
                "filled": int(filled[i]),
                "time": first_times[i],
                "data": raw_data
            }
            objects.append(obj)
    return objects

def convert_phot64_data(phot64_obj):
    raw_data = phot64_obj["data"][:phot64_obj["filled"]]
    raw_data = np.asarray(raw_data, dtype=np.uint64)
    time_int = raw_data >> 32
    y_packed = (raw_data >> 12) & 0xFFFFF  # 20 bits for magnitude (sign–magnitude)
    dy_int = raw_data & 0xFFF              # 12 bits for error
    sign_mask = 1 << 19
    y_int = np.where((y_packed & sign_mask) != 0, - (y_packed & 0x7FFFF), y_packed)
    time_vals = phot64_obj["time"] + time_int.astype(np.float64) * TIME_QUANT
    mag_vals = y_int.astype(np.float64) * Y_QUANT
    err_vals = dy_int.astype(np.float64) * DY_QUANT
    data = np.column_stack((time_vals, mag_vals, err_vals))
    return data, ["time", "magnitude", "error"]

# -------------------------------
# Lazy widget for phot64 object tabs
# -------------------------------
class LazyPhot64ObjectWidget(LazyWidgetBase):
    def __init__(self, file_path, phot64_obj, parent=None):
        super().__init__(file_path, parent)
        self.phot64_obj = phot64_obj

    def _load_data_impl(self):
        # Use the provided conversion function to load data.
        return convert_phot64_data(self.phot64_obj)

    def _get_data_title(self):
        # Display the phot64 object's ID.
        return self.phot64_obj['id']

    def _get_error_prefix(self):
        return "Error loading phot64 object data:"

    def _get_plot_title(self):
        return self.phot64_obj.get('id', 'Plot')


# -------------------------------
# Lazy widget for non–phot64 files (single file photometry)
# -------------------------------
class LazyTableWidget(LazyWidgetBase):
    def __init__(self, file_path, load_func, parent=None):
        super().__init__(file_path, parent)
        self.load_func = load_func  # Function to load the file
        self.plot_data_col_major = None  # For reordering the data for plotting

    def _load_data_impl(self):
        return self.load_func(self.file_path)

    def _get_data_title(self):
        base_filename = os.path.basename(self.file_path)
        filename_without_extension, _ = os.path.splitext(base_filename)
        return filename_without_extension

    def _get_error_prefix(self):
        return "Error loading file:"

    def _get_plot_title(self):
        return os.path.splitext(os.path.basename(self.file_path))[0]

    def _get_plot_series_data(self):
        # Reorder the data in column-major order before plotting.
        self.plot_data_col_major = np.array(self.data, order='F')
        times = self.plot_data_col_major[:, 0]
        mags = self.plot_data_col_major[:, 1]
        for t, m in zip(times, mags):
            yield float(t), float(m)


# -------------------------------
# Table model (unchanged)
# -------------------------------
class NumpyTableModel(QtCore.QAbstractTableModel):
    def __init__(self, data, headers, parent=None):
        super().__init__(parent)
        self._data = data
        self._headers = headers

    def rowCount(self, parent=QtCore.QModelIndex()):
        return self._data.shape[0]

    def columnCount(self, parent=QtCore.QModelIndex()):
        return self._data.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DisplayRole:
            col_header = self._headers[index.column()].lower()
            raw_value = self._data[index.row(), index.column()]
            try:
                val = float(raw_value)
            except Exception:
                return str(raw_value)

            # Format "time": truncate to 6 decimal places at most.
            if col_header == "time":
                truncated = np.trunc(val * 1e6) / 1e6
                s = f"{truncated:.6f}"
                s = s.rstrip('0').rstrip('.') if '.' in s else s
                return s

            # Format "error": truncate to 2 significant digits.
            elif col_header == "error":
                if np.isnan(val):
                    return "nan"
                if val == 0:
                    return "0"
                exponent = np.floor(np.log10(abs(val)))
                scale = 10 ** (exponent - 2)
                truncated_val = np.floor(val / scale) * scale
                if abs(truncated_val) < 1e-2:
                    s = f"{truncated_val:.2e}"
                else:
                    s = format(truncated_val, ".2g")
                return s

            # Format "magnitude": if error isn’t NaN, use ceil(-log10(error)+1) decimals; else 4 decimals.
            elif col_header == "magnitude":
                headers_lower = [h.lower() for h in self._headers]
                if "error" in headers_lower:
                    error_idx = headers_lower.index("error")
                    try:
                        error_val = float(self._data[index.row(), error_idx])
                    except Exception:
                        error_val = np.nan
                    if np.isnan(error_val) or error_val == 0:
                        dp = 4
                    else:
                        dp = int(np.ceil(-np.log10(error_val) + 1))
                else:
                    dp = 4
                truncated = np.trunc(val * (10 ** dp)) / (10 ** dp)
                s = f"{truncated:.{dp}f}"
                s = s.rstrip('0').rstrip('.') if '.' in s else s
                return s

            else:
                return str(raw_value)
        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                if section < len(self._headers):
                    return self._headers[section]
            else:
                return str(section)
        return None

# -------------------------------
# Customized Search LineEdit with forced–search support
# -------------------------------
class SearchLineEdit(QtWidgets.QLineEdit):
    # Custom signal to indicate a forced search (via Tab or Enter)
    forceSearch = QtCore.pyqtSignal()

    def keyPressEvent(self, event: QtGui.QKeyEvent):
        # For Tab, Return, or Enter, emit forceSearch and do not pass the event on.
        if event.key() in (Qt.Key.Key_Tab, Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self.forceSearch.emit()
            event.accept()
            return
        super().keyPressEvent(event)

    def focusNextPrevChild(self, next: bool) -> bool:
        # Override to prevent Tab from moving focus away.
        return False

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()

    # Process command-line arguments.
    for arg in sys.argv[1:]:
        if arg.strip():
            window._process_path(arg)

    # If only a few non–phot64 files are pending, open them as tabs.
    if len(window.pending_files) <= 10:
        for file_path in window.pending_files.copy():
            window.add_file_tab(file_path)
    else:
        window.update_search_results(window.search_bar.text(), False)

    window.resize(800, 600)
    window.show()
    sys.exit(app.exec())
